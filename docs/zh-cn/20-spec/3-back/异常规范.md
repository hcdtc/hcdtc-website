# 异常处理规范

## 异常分类
- 可检查异常需要在方法上声明，一般要求调用者必须感知异常可能发生，并且对可能发生的异常进行处理。可以理解成系统正常状态下很可能发生的情况，通常发生在通过网络调用外部系统或者使用文件系统时，在这种情况下，错误是可能恢复的，调用者可以根据异常做出必要的处理，例如重试或者资源清理等。
- 非检查异常是不需要在throws子句中声明的异常。JVM根本不会强制您处理它们，因为它们主要是由于程序错误而在运行时生成的。它们扩展了RuntimeException。最常见的例子是NullPointerException 可能不应该重试未经检查的异常，并且正确的操作通常应该是什么都不做，并让它从您的方法和执行堆栈中出来。在高执行级别，应记录此类异常。
- Error是最为严重的运行时错误，几乎是不可能恢复和处理，一些示例是OutOfMemoryError，LinkageError和StackOverflowError。它们通常会使程序或程序的一部分崩溃。只有良好的日志记录练习才能帮助您确定错误的确切原因。

## 异常处理规范

- 永远不要吞噬异常
    - 在所有异常被捕获且没有重新抛出的地方必须写日志
    - 日志中必须传入原始异常，例如，logger.error(e.getMessage(), e)
    - 如果属于正常异常的空异常处理块必须注释说明原因，否则不允许空的catch块

- 尽量使用特定的异常，而不是通用的Exception

- 永远不要捕获Throwable，Error也是继承自它，Error是Jvm都处理不了的错误

- 正确封装和传递异常，重新抛出的异常必须保留原来的异常，即`throw new NewException("message", e); `而不能写成`throw new NewException("message")`

- 打印异常和抛出异常不要同时做，只会打印出重复的日志；但是建议通过日志将上下文信息打印出来，例如，参数信息

- 不要在finally块中抛出异常，如果在finally中抛出异常，将会覆盖原始的异常,如果finally中真的可能会发生异常，那一定要处理并记录它，不要向上抛

- 不要使用printStackTrace，要给异常添加上有用的上下文信息，单纯的异常栈，没有太大意义

- Throw early catch late

异常界著名的原则，错误发生时及早抛出，然后在获得所以全部信息时再捕获处理.也可以理解为在低层次抛出的异常，在足够高的抽象层面才能更好的理解异常，然后捕获处理。

- 资源操作一定记得清理，如网络连接、数据库连接、文件流连接等，通过`try-finally或者try-resource`进行清理

- 及早校验用户输入

- Feign调用必须使用FallbackFactory方式进行熔断或异常处理，这样才有机会打印异常信息。